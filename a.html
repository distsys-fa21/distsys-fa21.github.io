---
layout: default
---
<!doctype html>
<html lang="en">

<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<!-- <link rel="stylesheet" href="style.css"> -->
<title>CSE 40771/60771 - Distributed Systems - Fall 2021</title>
</head>

<h1>Assignments - General Guidance</h1>

<h2>Python 3 Environment</h2>

<h2>Focus on Standard Libraries</h2>

The general approach for solving the programming assignments in this class is to
learn how to use the basic Python language and standard libraries to build up
complex systems.  This will help you to understand these capabilities in detail
and develop the skills for building new libraries of your own.  In particular,
you will have the opportunity to become familiar with the following standard libraries:

<ul>
<li> files
<li> processes
<li> sockets
<li> json
<li> time
</ul>
 
Now, there do exist various additional packages and libraries that provide
implementations of some of the techniques that we discuss: remote procedure call,
consensus, persistence, and so forth.  However, we won't be using those, because
simply "installing package X" doesn't lead to any new understanding or experience.
If you find yourself trying to solve a technical problem by installing a new 
package, then you are probably taking the wrong approach to the assignment.

On a related note, exercise care when searching for solutions online.
Q&amp;A sites like Stack Overflow can be helpful when trying to understand
obscure error messages, or find the right standard library to use.
However, don't just uncritically copy a bit of code that you find:
it may be solving a different problem, it may be an "advertisement" for someone's
favorite package, or it may not work at all.  Use that solution as a "clue"
to read the documentation for that particularly function or library, so that
you can understand how to use it yourself.

<h2>Git Repository  Management</h2>



<h1>Assignment A1 - Measurement</h1>

The first assignment will be a warm up in which you conduct a careful
measurement of the costs of basic operations in distributed systems.
To that end, write a series of small Python programs that measure the time to do the following things on the student machines:

<ol>
<li> Make a function call.
<li> Create/delete a file in your home directory.
<li> Create/delete a file in <tt>/tmp/</tt>
<li> Create a child process and wait for it to complete.  (The child process should do nothing but <tt>exit</tt>)
<li> Get the current wall clock time.
<li> Insert an item into a Python dictionary.
<li> Make a TCP connection to a well-known internet service.
<li> Open a file containing a large JSON document, and parse it.  (Check out <a href=http://www.json-generator.com>json-generator.com</a>
</ol>

Of course, there is little value in measuring a <i>single</i>
one of these items, one of which may be faster than the resolution
of the clock.  So, measure how long it takes a number of items
in a loop, such that the loop takes at least a second.  (This might require millions of items for the fast ones, or perhaps just a hundred for the slow ones.)

<h2>Turning In</h2>

Turn in each of your Python programs, naming them <tt>Test1.py</tt>, <tt>Test2.py</tt>, ... corresponding to the numbering above.
To that, add a README.md file that describes the specifics of what you measured, and 


<h1>Assignment A2 - Remote Procedure Call</h1>

In this assignment, you will build an online service that supports
access to an in-memory hash table running on a single machine.
This will provide the basic capability that we will build upon over
several assignments to work up to a fully distributed, scalable hash table.
The focus of this assignment will be on the remote procedure call (RPC)
interface to the system.

<h2>Hash Table Interface</h2>

Your hash table RPC should support the following four operations:

<pre>
insert( key, value ) -> returns success or failure
lookup( key ) -> returns a value
remove( key ) -> returns success or failure
scan( regex ) -> returns all (key,value) pairs where the key matches the regular expression 
</pre>

Across the calls, a key may be a plain string, a value can be an arbitrary JSON structure, and a regex is a plain string.  You should design an appropriate set of messages that represent a request and response for each operation.

<h2>General Structure</h2>

To ensure some degree of consistency across the projects, please follow this structure in your code:

<ul>
<li> <b>HashTable.py</b> should contain the basic implementation of each of the four operations on a plain hash table in memory.
<li> <b>RPCServer.py</b> should contain the server-side RPC main program.
It should create a listening TCP socket, display the host and port it is
listening on, accept incoming connections, decode messages coming from the
client, invoke the proper operation, and then return the result.
<li> <b>RPCClient.py</b> should contain the client-side RPC operations.
It should provide a method to connect to a server host and port,
and a client-stub for each of the four hash table operations that sends
a message and waits for the response.  
<li> One or more client main programs named <b>Test*.py</b> should make use
of RPCClient.py to connect to the server and invoke RPC operations as needed.
</ul>

<h2>Testing and Measurement</h2>

Evaluate the performance of your RPC service in a similar way as to the first assignment.

To evaluate the performance of this RPC service, you should write several
main test programs that exercise the four key operations in the hash table interface in various combinations.  The exact design of these tests is up to you, keeping in mind that performance may be affected by the number of items in the table.

As with the previous assignment, you should present your results not as
simple averages, but histograms that display the variation in performance
over a large number of measurements.

<h2>What to Turn In</h2>

Turn in all of your source code 

Write a README.md that details the following:
- The design of the messages used for convey RPC requests/responses.
- Your approach to measuring the performance of the system.


<h1>Assignment A3 - Persistence</h1>

A hash table that keeps its state solely in memory will los information when
the server machine crashes or reboots.  In this assignment, you will augment
the server to use a checkpoint-and-log approach to managing persistent state,
following the method discussed in class.

<h2>Logging and Checkpointing</h2>

Take your prior implementation of the hash table (and test cases) from <tt>a2</tt>
and copy it into a new directory <tt>a3</tt>.  Then, modify your new implementation
as follows:

<ul>
<li> The RPC server should continue to maintain a hash table in memory,
but should also record its state into a transaction log named <tt>txn.log</tt>.
Read-only operations can be satisfied from the in-memory copy, but every modification
to the table should be capture by appending a log record to the transaction log.

<li> When starting (or re-starting), the RPC server should re-construct the
state of the hash table by reading the transaction log and applying each change
to the in-memory hash-table.  You can test that this works correctly by killing
the server with Control-C, and then restarting it by hand.

<li> When the current transaction log becomes too large, the RPC server should write
out a new (compacted) transaction log, and then atomically renaming it over the
old transaction log.
</ul>

<h2>Measurement</h2>

Repeat your performance measurements from the prior assignment,
and compare the performance of 

<h2>What to Turn In</h2>


<h1>Assignment A4 - Discovery</h1>

In this assignment, we will lay the groundwork for running multiple instances
of the hash table in a cluster.  In order to do that, we must be able to discover
and name each process in the cluster, and also be able to support mulitple clients
accessing the same server at each time.

<h2>Discovery</h2>

<h2>Multiple Clients</h2>



<h2>
In this assignment, you will extend your implementation of 



</body>
</html>
